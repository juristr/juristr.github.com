---
title: Passing Property Names the "compiler-safe" Way
date: 2010-07-29T00:00:00.000Z
comments: true
categories:
- CSharp
- ".Net"
url: /blog/2010/07/passing-property-names-compiler-safe
type: post
---

<p>A common bad practice which I often find when browsing through code is to see people directly hard-code strings in
  their source code. I've also proposed some refactorings in <a href="http://blog.js-development.com/2009/05/string-enumerations-in-c.html">some
  </a>of <a href="http://blog.js-development.com/2010/01/comments-smell-replace-them-with-more.html">my previous posts</a>.
  Today I'd like to blog about a similar issue which targets the issue of <b>object property referencing</b> within
  code.</p>

I guess most of us already had the case where you give a property of your entity like <br />
<pre class="prettyprint">SomeHelper.Validate(entityObject, "somePropertyName", value);<br />SomeHelper.Validate(entityObject, "someOtherPropertyName", value);</pre>This
"strange" assignment because SetProperty takes objects in a generic way and validates the specified property. Note,
this is not real-world code, so don't be scared :) , but it may arise in similar ways throughout your code-base.<br />Another
use case I was currently experiencing and which was the reason for writing this blog post is when announcing a problem
about some property to the system user (i.e. in a log). In such a case you'd probably write<br />
<pre class="prettyprint">MyLogger.LogProblem("SomePropertyName", "Some message from a resource file");</pre><br />So
what's the problem with such code?<br />
<ul>
  <li><b>No compile-time-checking</b><b>!</b>&nbsp;Changing the property name of your object, won't give you any error
    during compile time but you may experience nice errors when the system is being used. Well ok, ReSharper does a
    nice job in also including such strings in refactorings, but still.<br />These kind of bugs are heavy, since you
    may have difficulties in spotting them.</li>
  <li>It is <b>cumbersome&nbsp;to type</b> and code because you have to remember the exact name of the property without
    any kind of Intellisense support.</li>
</ul>These issues can be solved by using a nice Linq construct.<br />
<pre class="prettyprint">public static void LogProblem&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; propertyExpression, string message)<br />{<br />    string propertyName = GetPropertyName(propertyExpression);<br />    if (propertyName == null)<br />        throw new NullReferenceException("The name of the property couldn't be retrieved!");<br /><br />    LogEntry logEntry = new LogEntry()<br />    {<br />        Fieldname = propertyName,<br />        MessageDescription = String.Format(message, propertyName)<br />    };<br /><br />    logEntries.Add(logEntry);<br />}<br /><br />public static string GetPropertyName&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; expression)<br />{<br />    MemberExpression body = (MemberExpression)expression.Body;<br />    return body.Member.Name;<br />}</pre>This
can then be used very nicely by rewriting the logging instruction I mentioned before like this<br />
<pre class="prettyprint">MyLogger.LogProblem(() =&gt; myObjInstance.SomePropertyName, "Some message from a resource file");<br /></pre>Voil√°,
you have a compile-time, fully intellisense supported logging method now. The only thing I don't really like is the
somehow strange-looking declaration of the property name by having to use <code>() =&gt;</code>&nbsp;...