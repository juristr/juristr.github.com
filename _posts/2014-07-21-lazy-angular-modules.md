---
layout: articles-post
title: "Lazy Angular Modules"
lead: "Modularization strategy for lazy Angular modules"
show_img_in_detail: false
coverimage: false
tags: ["JavaScript", "Angular.js"]
---

Startup time is crucial for a proper user experience and that's where many JavaScript SPA really fail. Even though you might (and definitely should) apply code minification and bundling mechanisms, you wouldn't want to load your entire application right upfront. It simply isn't useful nor required. Unfortunately, as of now Angular doesn't natively support any kind of lazy loading approach. Thus, many devs started to create custom implementations and workarounds to circumvent such lack. This article aims to explore those implementations as well as to combine them with another interesting and hotly-debated topic: proper modularization.

{% assign topics='Updates will include existing approaches from other devs as well as source code samples and a detailed explanation of the implementation details.' %}
{% include mycustoms/next-up %}

## Feature based vs MVC based organization

Not only Angular but other frameworks as well propose the typical MVC kind of structuring and organization of your code, having a

- `controller` folder
- `model` folder
- `view` folder
- ...

While this might seem to be a clean and well organized structure initially, you soon discover that it isn't quite as useful as it could be during development nor maintenance. When did you last open your project and say "let's add a controller"?? Instead, you normally implement or modify some feature.  
Having a MVC structure implies a continuous, tedious searching for the corresponding controller, the model and view that belong to the feature in these three separate folders. 

<figure>
  <img src="/blog/assets/imgs/lazy-angular/mvc-based-org.png" />
  <figcaption>Contrary: MVC based structuring generated by the official Angular Yeoman generator</figcaption>
</figure>

Thus, having  a "feature-based" organization and grouping of your code tends to be more useful and maintainable in the long run. Unfortunately, many Angular examples, even official ones, promote the MVC based folder structure (as of now). Take the [angular-seed](https://github.com/angular/angular-seed/tree/master/app/js) project or the [official Yeoman generator][official_yeoman_generator].  
That seems to change, though. The latest official [Angular best practices guide on GitHub][official_bestpractices] proposes to "group your code into related bundles" and references the [Angular-app][angular_book_source] demo which is the code example that accompanies the [Mastering Web Application Development with AngularJS][angular_book] book (must read!). 

What you read and hear across the community might not always be as consistent as you'd like to have it. Anyway, my approach clearly follows the feature-based cut as it has already proven to be fruitful when developing JavaScript SPAs with JavaScriptMVC/CanJS as well as on a desktop application developed with PRISM.net.

The projects to take a look at for a proper feature-based organization is the source for the Angular book: [GitHub link][angular_book_source]. The image below illustrates this further.

<figure>
  <img src="/blog/assets/imgs/lazy-angular/feature-based-org.png" />
  <figcaption>Feature based code organization by the angular-app sample.</figcaption>
</figure>

Furthermore [John Papa held a session at this year's TechEd][johnpapa_videoteched] about creating modular Angular applications with the .Net stack. While the backend is less interesting for this article, in [his frontend][johnpapa_code] he nicely follows such feature based organization.

### Implementing a feature based approach in Angular

Angular already disposes of a "module system" which provides some sort of namespacing. That system naturally fits in the feature-based approach, so [instead of having modules like][official_bestpractices]

- `app.controllers`, `app.services` you have
- `app.users`, `app.users.edit`, ...

Furthermore, [John Papa](https://github.com/johnpapa/ng-demos/tree/master/modular/client/app/dashboard) structures each module to reside in its own folder..

<figure>
  <img src="/blog/assets/imgs/lazy-angular/module-structure-papa.png" />
  <figcaption>Example: a module's internal structure (by John Papa)</figcaption>
</figure>

..and to contain a dedicated file that just contains the Angular module's definition and eventual dependencies loading: `<modulename>.module.js`.

```javascript
(function () {
    'use strict';
    angular.module('app.dashboard', []);
})();
```

The [official angular demo][angular_book_source] [follows a nearly identical approach](https://github.com/angular-app/angular-app/tree/master/client/src/app/admin), but instead of having a file named `<modulename>.module.js` it defines it like `<modulename>.js`.

<figure>
  <img src="/blog/assets/imgs/lazy-angular/module-structure-angapp.png" />
  <figcaption>Example: a module's internal structure (by official Angular-app demo)</figcaption>
</figure>

Internally that file specifies the module name and dependencies:

```javascript
angular.module('admin', ['admin-projects', 'admin-users']);
```

The approach taken by both sounds reasonable and is what I ended up mirroring with RequireJS (as we'll see later). The only variable here is the **name of the angular module which gets repeated as hardcoded strings** among submodules. Related to that topic I found an interesting article by Avi Haiat about [AngularJS and RequireJS for Very Large Applications](http://thaiat.github.io/blog/2014/02/26/angularjs-and-requirejs-for-very-large-applications/). He follows an approach where each module has at least the following files:

`namespace.js` - defines the module's name as an AMD module, taking the root namespace (`../namespace`) and combines it with the current module's name.

```javascript
define([
    '../namespace'
], function(rootNamespace) {
    'use strict';

    return rootNamespace + '.moduleone';
});
```

`module.js` - is the actual definition of the Angular module, importing the defined namespace.

```javascript
define([
    'angular',
    './namespace'
], function(angular, namespace){
    'use strict';

    // module definition
    return angular.module(namespace, []);
});
```

`module.require.js` - is used for collecting all of the files needed for RequireJS to properly load the module. It basically bundles all of the module's files s.t. any user has just to "require" the this file to get everything.

```javascript
define([
    './module',
    ..,
], function(){ 
});
```

In this way you can change the module names at a single point without having to edit multiple files with hardcoded strings. Although it sounds great from a theoretical perspective, I'm not yet sure about whether the overhead of having additional files just for carrying the namespace pays off. We'll see...

## State of the Art of Lazy Loading in JavaScript

Currently [RequireJS][require_js] is definitely the state of the art in asynchronously (and lazy) loading of JavaScript files. It is based upon the [AMD (Asynchronous Module Definition)](http://requirejs.org/docs/whyamd.html) API.

The basic usage consists of defining an AMD module, say `myModule.js`

```javascript
define(['jquery', './logger.js'], function($, logger){
    // do something

    return {
        doSomething: function(){
            logger.log('Hi');
        }
    }
});

```

...which you can then "require" somewhere else.

```javascript
require(['./myModule.js'], function(myModule){
    // do something interesting with it 
});
```

The asynch and potentially even parallel loading of the necessary files is completely managed by RequireJS.

## Lazy loading and dependency injection

But, Angular has already it's "dependency injection" mechanism. Why would I want to also use RequireJS? The two have different targets: **RequireJS loads your physical script files** into the browser while Angular's dependency injection mechanism loads a **logical, runtime artifact by its name**.

In order to have Angular's DI mechanism work properly, all of the JavaScript code has to be loaded and known by the framework. Angular analyzes the code for definitions of controllers, services, directives etc. and injects them at other points when requested. For instance, you define your service:

```javascript
// definition of a service on an existing Angular module
myModule.factory('consolelogger', function(){
    return function(msg){
        console.log(msg)
    }   
});
```

Then, somewhere else you specify your `consolelogger` as dependency.

```javascript
myModule.controller('MyController', ['consolelogger', function(consolelogger){
    consolelogger('hi there');
}]);
```

<p class="notice fact">
    In Angular's DI you don't have to specify the file location, but simply the name with which you defined your artifact!
</p>

Thus, Angular's DI is good for testing and better modularity while RequireJS (or alternatives like [$scriptjs](http://www.dustindiaz.com/scriptjs) and so on) is definitely the tool for lazy-on-demand loading. But attention, we cannot simply lazy-load some JavaScript files with RequireJS after our Angular app has started because the DI container simply wouldn't recognize those newly created artifacts. Instead, we need to manually tell Angular about those new files that arrived. More on that later.

## Angular and RequireJS for Lazy loading

### Existing approaches for lazy loading

When I researched for a proper appraoch on implementing lazy loading in Angular, (after googling a bit) I commented on the [AngularJS Googel Group][googlegroups_lazyloading]. The comments from others, revealed mostly the resources I already found on the web:

- [Ifeanyi Isitor on lazy loading with `$scriptjs`][isitor_scriptjs]. He also added an implementation [using RequireJS][isitor_requirejs].
- Bennadel on [his approach to using RequireJS for lazy loading][bennadel_requirejs].
- [angularAMD](http://marcoslin.github.io/angularAMD/#/home) - a project that combines AngularJS+RequireJS in a library for better reusability.

All of them differ only sightly from each other.



### Implementation

In my implementation I started by using Isitor's implementation using RequireJS, combined John Papa's ng-demo code and the suggestions from the Angular book (I referenced) for the feature-based modularization as well as Avi Haiat's suggestions to reduce hardcoded Angular module names.

<p class="notice tip">
    The source code can be found at <a href="https://github.com/juristr/lazy-angular" target="_blank">my GitHub repository</a>.
</p>

So, where to start..? I pre-generated the initial project scaffold by using the [Yeoman Angular generator for RequireJS](https://github.com/aaronallport/generator-angular-require). Basically to have an initial setup with RequireJS and everything already in place.

When you use RequireJS you have to use [Angular's deferred bootstrap](https://code.angularjs.org/1.2.1/docs/guide/bootstrap#overview_deferred-bootstrap) approach because Angular has to wait for Require to load all of the necessary files before booting up. As a consequence, in the index.html you have a single line that starts RequireJS and instructs it to load `main.js`.

```html
<body>
    ...
    <script src="bower_components/requirejs/require.js" data-main="scripts/main.js"></script>
</body>
```

`main.js` loads loads all of the Angular files you need, like `angular-route`, `angular-resource` and so on. Then it calls `angular.resumeBootstrap(..)`. The more important file is `app.js` as that's where the application code really appears. But before going ahead with that, let's first take a look at how the lazy loading is actually implemented.

To lazy load parts of the application we need two steps

1. load the required JavaScript files
1. dynamically register them with the Angular dependency injection mechanism

**Step 1)** is done with RequireJS and it is pretty straightforward

```javascript
...
require(dependencies, function(){
    // do something with 'em
});
...
```

At this point we have the JavaScript files loaded and interpreted in the browser. Being an async call "outside the Angular world" we need to make Angular aware of the changes by calling the $digest loop.

```javascript
require(dependencies, function() {
    $rootScope.$apply(function() {
        deferred.resolve();
    });
});
```

**Step 2)** involves more trickery because Angular needs to know upfront about all of the available resources in order to have its DI mechanism work properly. We can make use of various `register` methods made available by some Angular providers to dynamically register new artifacts like controllers, services, directives etc.  
More specifically...

- `$controllerProvider.register` for registering new controllers ([see docs](https://docs.angularjs.org/api/ng/provider/$controllerProvider#register))
- `$compileProvider.directive` for registering new directives ([see docs](https://docs.angularjs.org/api/ng/provider/$compileProvider))
- `$filterProvider.register`; ([see docs](https://docs.angularjs.org/api/ng/provider/$filterProvider))
- `$provide.factory` and `$provide.service` for registering new factories and services ([see docs](https://docs.angularjs.org/api/auto/service/$provide))

Since these functions are only available at [configuration time](https://docs.angularjs.org/guide/module), we need to keep a reference for later usage.

```javascript
app.config([
    ...
    '$controllerProvider',
    '$compileProvider',
    '$filterProvider',
    '$provide',
    ...
    function(..., $controllerProvider, $compileProvider, $filterProvider, $provide, ...) {
      app.controller = $controllerProvider.register;
      app.directive = $compileProvider.directive;
      app.filter = $filterProvider.register;
      app.factory = $provide.factory;
      app.service = $provide.service;
      ...
    }
]);
```

Due to this overwriting of the standard functions, all subsequent controller, service, directive...registrations now use the modified ones, allowing to register artifacts later in the application's lifecycle, thus being essential for a lazy loading approach.

```javascript
app.controller('MyController', ['$scope', function($scope){
    ...
}]);
```

`app.controller` points to the `$controllerProvider.register` function which is completely transparent during development.

{% comment %}

### Weaknesses, open points

- having a dedicate `namespace.js` just for the purpose of not hardcoding the Angular mdoule name.
- scripts folder rather than an app folder that contains everything
- Spread route definitions across multiple module .config() methods

## Conclusion

{% endcomment %}

## References

- [Mastering Web Application Development with AngularJS][angular_book]
- [Official Yeoman Angular generator][official_yeoman_generator]
- [John Papa TechEd 2014: Building Rich Apps with AngularJS on ASP.net][johnpapa_videoteched] and [demo code repository][johnpapa_code]
- [RequireJS homepage][require_js]
- [Google Groups post on lazy loading][googlegroups_lazyloading]
- [Ifeanyi Isitor's lazy loading using $scriptjs][isitor_scriptjs]


[angular_book]: http://www.packtpub.com/angularjs-web-application-development/book
[angular_book_source]: https://github.com/angular-app/angular-app/tree/master/client/src/app
[official_yeoman_generator]: https://github.com/yeoman/generator-angular
[johnpapa_code]: https://github.com/johnpapa/ng-demos/tree/master/modular
[johnpapa_videoteched]: http://channel9.msdn.com/Events/TechEd/NorthAmerica/2014/DEV-B420
[require_js]: http://requirejs.org/
[googlegroups_lazyloading]: https://groups.google.com/forum/#!topic/angular/kJEgckFT19Y
[isitor_scriptjs]: http://ify.io/lazy-loading-in-angularjs/
[isitor_requirejs]: https://github.com/ifyio/angularjs-lazy-loading-with-requirejs
[bennadel_requirejs]: http://www.bennadel.com/blog/2554-loading-angularjs-components-with-requirejs-after-application-bootstrap.htm
[official_bestpractices]: https://github.com/angular/angular.js/wiki/Best-Practices