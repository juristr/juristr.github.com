---
layout: post
title: "Testing and the Single Responsibility Principle"
date: 2012-07-26
comments: true
tags: [  Unit Testing, Best Practices, Software testing ]
reposts: ["http://www.dotnetcodegeeks.com/2012/09/testing-and-single-responsibility.html", "http://www.dzone.com/articles/testing-and-single"]
---

<p>Automated testing is hard! Therefore, if you're about to learn it, just keep going. Resist the initial learning curve as afterwards it'll allow you to adopt a completely different programming style. A common problem I've observed is that (mainly) "testing newbies" tend to create huge, bloated tests cases which quickly start to get unmanageable. Usually this discourages them and they abandon their tests. So what's the key?</p>

When you start with automated (unit) testing, you usually apply a test-after approach. That's natural. While I think you <b>should jump into testing in a test-first</b> manner immediately, you will naturally end up doing test-after and then eventually slowly move back to real test-first. This test-after approach however is what lets you create big huge test cases normally as it is extremely difficult to focus on the single test cases.<br /><h2>An Example</h2>Maintainability is one important aspect of creating successful tests, however, also <b>feedback</b> is extremely important. When you create automated tests, what you want to achieve in the end is to build a system that will notify you about any problems as early as possible: <b>you increase the feedback loop, basically</b>. Instead waiting for some human tester to provide you feedback in the form of a bug report, you let the automated test case give you that feedback <b>while coding and adding new stuff</b>.<br />For example:<span style="background-color: white;">&nbsp;</span><br /><pre class="brush:csharp">[TestMethod]<br />public void ShouldReturnCleanedConnectionStringAndSchemaTranslations()<br />{<br />    //snip snip snip<br />                <br />    Assert.AreEqual(cleanConnString, result);<br />    Assert.AreEqual(1, schemaTranslations.Count(), "There should be 1 schema translation");<br />}<br /></pre><span style="background-color: white;">When this test fails, do you know what went wrong?? Yes, you have to open the details of the test failure and see which assert failed. But wouldn't it be better to split them (you see the "AND" in the test name) and create two, like</span><br /><pre class="brush:csharp">[TestMethod]<br />public void ShouldReturnCleanedConnectionString()<br />{<br />    //snip snip snip<br />                <br />    Assert.AreEqual(cleanConnString, result);}<br />}<br /><br />[TestMethod]<br />public void ShouldReturnSchemaTranslations()<br />{<br />    //snip snip snip<br />                <br />    Assert.AreEqual(1, schemaTranslations.Count(), "There should be 1 schema translation");<br />}<br /></pre>Now when one of those two tests fails you immediately see which kind of code is probably broken, right?This kind of approach has several advantages. You now even optimized the provided feedback in that - in the best case - you don't have to even open the details and start to debug in order to understand what broke your test. Moreover&nbsp;<span style="background-color: white;">when you refactor your code you have to touch less tests. Remember, </span><b style="background-color: white;">small tests tend to break less often</b><span style="background-color: white;"> than large, big fat test methods. And finally, small tests are much easier to understand, fix, adapt etc...</span><br /><h2>  Naming Conventions May Help</h2>Good naming may actually help you identify tests with multiple responsibilities. These worked well for me:<br /><ul><li>GivenSomethingIsTrueThenItShouldReturnSomeSpecificResult</li><li>ShouldReturnSomeSpecificResult</li></ul><div>Already when formulating the test name you quite quickly see any muliple expectations.<span style="background-color: white;">&nbsp;What do you think?</span></div>